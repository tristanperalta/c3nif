defmodule C3nif.Generator do
  @moduledoc """
  Generate C3 NIF entry point code.

  This module generates the C3 code needed to register NIFs with the Erlang runtime:
  - `ErlNifFunc` array with function metadata
  - `nif_init` function that returns the `ErlNifEntry`

  ## Generated Code Structure

  ```c3
  // === AUTO-GENERATED NIF ENTRY ===
  ErlNifFunc[N] __c3nif_funcs__ = {
      { .name = "func1", .arity = 1, .fptr = &func1, .flags = 0 },
      { .name = "func2", .arity = 2, .fptr = &func2, .flags = erl_nif::ERL_NIF_DIRTY_JOB_CPU_BOUND },
  };

  ErlNifEntry __c3nif_entry__;

  fn ErlNifEntry* nif_init() @export("nif_init") {
      __c3nif_entry__ = c3nif::make_nif_entry(
          "Elixir.MyModule",
          &__c3nif_funcs__,
          N,
          &on_load,  // or null
          null
      );
      return &__c3nif_entry__;
  }
  ```
  """

  alias C3nif.Parser.{NifFunction, Callbacks}

  @doc """
  Generate C3 entry point code for the given NIFs and callbacks.

  ## Parameters

  - `module_name` - The Elixir module name (e.g., "Elixir.MyApp.MyNif")
  - `nifs` - List of `NifFunction` structs
  - `callbacks` - `Callbacks` struct with on_load/on_unload

  ## Returns

  C3 source code string to append to the user's C3 code.
  """
  @spec generate_entry(String.t(), [NifFunction.t()], Callbacks.t()) :: String.t()
  def generate_entry(module_name, nifs, callbacks) do
    count = length(nifs)

    if count == 0 do
      raise ArgumentError, "No NIF functions found. Did you forget to add @nif annotations?"
    end

    funcs_array = generate_funcs_array(nifs, count)
    nif_init = generate_nif_init(module_name, count, callbacks)

    """
    // === AUTO-GENERATED NIF ENTRY ===
    // Generated by C3nif - do not edit manually

    #{funcs_array}

    ErlNifEntry __c3nif_entry__;

    #{nif_init}
    """
  end

  @doc """
  Generate complete C3 source by appending entry point to user code.

  ## Parameters

  - `user_code` - The user's C3 source code
  - `module_name` - The Elixir module name
  - `nifs` - List of `NifFunction` structs
  - `callbacks` - `Callbacks` struct

  ## Returns

  Complete C3 source code ready for compilation.
  """
  @spec generate_complete(String.t(), String.t(), [NifFunction.t()], Callbacks.t()) :: String.t()
  def generate_complete(user_code, module_name, nifs, callbacks) do
    entry_code = generate_entry(module_name, nifs, callbacks)
    "#{user_code}\n\n#{entry_code}"
  end

  # ===========================================================================
  # Private Functions
  # ===========================================================================

  defp generate_funcs_array(nifs, count) do
    entries =
      nifs
      |> Enum.map(&generate_func_entry/1)
      |> Enum.join(",\n    ")

    """
    ErlNifFunc[#{count}] __c3nif_funcs__ = {
        #{entries}
    };\
    """
  end

  defp generate_func_entry(%NifFunction{} = nif) do
    flags = dirty_flag(nif.dirty)

    ~s[{ .name = "#{nif.elixir_name}", .arity = #{nif.arity}, .fptr = &#{nif.c3_name}, .flags = #{flags} }]
  end

  defp dirty_flag(nil), do: "0"
  defp dirty_flag(:cpu), do: "erl_nif::ERL_NIF_DIRTY_JOB_CPU_BOUND"
  defp dirty_flag(:io), do: "erl_nif::ERL_NIF_DIRTY_JOB_IO_BOUND"

  defp generate_nif_init(module_name, count, callbacks) do
    load_ptr = callback_ptr(callbacks.on_load)
    unload_ptr = callback_ptr(callbacks.on_unload)

    """
    fn ErlNifEntry* nif_init() @export("nif_init") {
        __c3nif_entry__ = c3nif::make_nif_entry(
            "#{module_name}",
            &__c3nif_funcs__,
            #{count},
            #{load_ptr},
            #{unload_ptr}
        );
        return &__c3nif_entry__;
    }\
    """
  end

  defp callback_ptr(nil), do: "null"
  defp callback_ptr(name), do: "&#{name}"
end
